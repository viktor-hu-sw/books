[{"id":0,"href":"/design-patterns-in-go/Creational-Patterns/","title":"Creational Patterns","parent":"Design Patterns in Go","content":""},{"id":1,"href":"/design-patterns-in-go/Structural-Design-Patterns/","title":"Structural Design Patterns","parent":"Design Patterns in Go","content":""},{"id":2,"href":"/design-patterns-in-go/Behavioral-Design-Patterns/","title":"Behavioral Design Patterns","parent":"Design Patterns in Go","content":""},{"id":3,"href":"/design-patterns-in-go/Creational-Patterns/builder/","title":"Builder and Functional Options","parent":"Creational Patterns","content":" Problem Builder Pattern Functional Options Pattern in Practice Problem Imaging a Config object that requires laborious and complicated initialization of many fileds, and there are some requirements for diffrent fields: Some fileds are required, some are optional, and some have default value.\nFor example, this table shows the requirement for creating a valid Client.\nField Required Default Additional Requirement Addr Y Port Y Method Y Either GET ot POST ConnTimeout N 10s \u0026lt; IOTimeout IOTimeout N 20s Retries N 1 PoolSize N 10 MaxSize: 100 1 2 3 4 5 6 7 8 9 type Client struct { Addr string Port int Method string ConnTimeout time.Duration IOTimeout time.Duration Retries uint8 PoolSize uint64 } In most cases most of of the fileds are not required, making constructor calls quite long and ugly.\n1 2 3 4 5 6 func NewClient(addr string, port int, method string, connTimeout time.Duration, IOTimeout time.Duration, retries uint8, poolSize uint64) *Client { //Do verification here //if pollSize \u0026gt; 100 //if IOTimeout \u0026gt; ConnTimeout return \u0026amp;Client{Addr: addr, Port: port, Method: method, ConnTimeout: connTimeout, IOTimeout: IOTimeout, Retries: retries, PoolSize: poolSize} } When we decide to add another filed to the Client struct, you have to change your constructor parameters which means you have also to change all the code that are dependent on this constructor!\nBuilder Pattern If you are Java programmer, you might have seen code like this before, which is a builder pattern.\n1 2 3 4 5 Config config = new Config.Builder(\u0026#34;127.0.0.1\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;GET\u0026#34;) .IOTimeout(100) .ConnTimeout(30) .Retry(3) .Build() We can reuse the same construction code when building different types of configs, for example, we can easily build a Config has PoolSize 50:\n1 2 3 4 Config config = new Config.Builder(\u0026#34;127.0.0.1\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;GET\u0026#34;) .PoolSize(50) .Retry(3) .Build() To support this Builder pattern, we need change our Go code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 type Client struct { Addr string Port int Method string ConnTimeout time.Duration IOTimeout time.Duration Retries uint8 PoolSize uint64 } type ClientBuilder struct { addr string port int method string connTimeout time.Duration ioTimeout time.Duration retries uint8 poolSize uint64 } func NewClientBuilder(addr string, port int, method string) *ClientBuilder { if method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; method != \u0026#34;POST\u0026#34; { //error handling } b := \u0026amp;ClientBuilder{addr: addr, port: port, method: method} b.connTimeout = 10 * time.Second b.ioTimeout = 20 * time.Second b.poolSize = 10 b.retries = 1 return b } func (c *ClientBuilder) WithConnTimeout(connTimeout time.Duration) *ClientBuilder { c.connTimeout = connTimeout } func (c *ClientBuilder) WithIOTimeout(ioTimeout time.Duration) *ClientBuilder { c.ioTimeout = ioTimeout } func (c *ClientBuilder) WithPoolSize(poolSize uint64) *ClientBuilder { c.poolSize = poolSize } func (c *ClientBuilder) WithRetries(retries uint8) *ClientBuilder { c.retries = retries } func (c *ClientBuilder) Build() *Client { return \u0026amp;Client{ Addr: c.addr, Port: c.port, Method: c.method, ConnTimeout: c.connTimeout, IOTimeout: c.ioTimeout, Retries: c.retries, PoolSize: c.poolSize, } } Then, we are able to construct Client according to our needs.\n1 2 3 4 client := new(ClientBuilder). WithConnTimeout(15 * time.Second). WithRetries(3). Build() Pros Cons Single Responsibility Principle. You can isolate complex construction code from the business logic. The overall complexity of the code increases since the pattern requires creating multiple new classes. You can reuse the same construction code when building various representations of objects. Functional Options Functional options is a paradigm in Go for friendly and extensible APIs popularized by Dave Cheney.\nFirst of all, let\u0026rsquo;s define a function type:\n1 type Option func(*Client) Then, let\u0026rsquo;s add two functions that extend the ability to make changes to Client\n1 2 3 4 5 6 7 8 9 10 11 func WithConnTimeout(connTimeout time.Duration) Option { return func(client *Client) { client.ConnTimeout = connTimeout } } func WithRetries(retries uint8) Option { return func(client *Client) { client.Retries = retries } } Pay attention to the return type, they are Option type which is a function. So we need to execute this function to make these configs effective to Client.\n1 2 3 4 5 6 7 type Options []Option func (opts Options) apply(client *Client) { for _, opt := range opts { opt(client) } } Finally, let\u0026rsquo;s modify our constructor to pass into opts.\n1 2 3 4 5 6 7 8 func NewClient(addr string, port int, method string, opts ...Option) *Client { client := \u0026amp;Client{Addr: addr, Port: port, Method: method} Options(opts).apply(client) return client } cli := NewClient(\u0026#34;127.0.0.1\u0026#34;, 8080, \u0026#34;GET\u0026#34;, WithRetries(10), WithConnTimeout(4)) Pattern in Practice Go-micro is a popular Go micro-services framework. We can find a good example of using Options Pattern in this project.\nWe can create a new service simply by calling NewService()\n1 service := micro.NewService() But we can also set some options when creating service:\n1 2 3 4 service := micro.NewService( micro.Name(\u0026#34;hello world\u0026#34;), micro.Version(\u0026#34;1.0\u0026#34;), ) Let\u0026rsquo;s dive into the source code to find out how this feature is supported.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 https://github.com/asim/go-micro/blob/master/micro.go type Option func(*Options) // NewService creates and returns a new Service based on the packages within. func NewService(opts ...Option) Service { return newService(opts...) } func newService(opts ...Option) Service { ... options := newOptions(opts...) ... // set opts service.opts = options return service } https://github.com/asim/go-micro/blob/master/options.go // Options for micro service type Options struct { Auth auth.Auth Broker broker.Broker Cache cache.Cache ... } func newOptions(opts ...Option) Options { opt := Options{ Auth: auth.DefaultAuth, Broker: broker.DefaultBroker, Cache: cache.DefaultCache, ... } for _, o := range opts { o(\u0026amp;opt) } return opt } // Name of the service func Name(n string) Option { return func(o *Options) { o.Server.Init(server.Name(n)) } } // Version of the service func Version(v string) Option { return func(o *Options) { o.Server.Init(server.Version(v)) } } "},{"id":4,"href":"/design-patterns-in-go/","title":"Design Patterns in Go","parent":"","content":""},{"id":5,"href":"/design-patterns-in-go/tags/option/","title":"option","parent":"Tags","content":""},{"id":6,"href":"/design-patterns-in-go/tags/","title":"Tags","parent":"Design Patterns in Go","content":""},{"id":7,"href":"/design-patterns-in-go/huadong/","title":"Huadong","parent":"Design Patterns in Go","content":""}]